<?xml version="1.0"?>
<doc>
    <assembly>
        <name>IronRuby.Libraries</name>
    </assembly>
    <members>
        <member name="T:IronRuby.StandardLibrary.BigDecimal.BigDecimal.Config">
            <summary>
            This class holds the configuration information for the BigDecimal calculations
            This information needs to be shared amongst all the instances of BigDecimal
            but cannot be held in static variable storage since we need to scope more finely
            than per assembly.
            </summary>
        </member>
        <member name="F:IronRuby.StandardLibrary.BigDecimal.BigDecimal.RoundingModes.None">
            <summary>
            No rounding
            </summary>
        </member>
        <member name="F:IronRuby.StandardLibrary.BigDecimal.BigDecimal.RoundingModes.Up">
            <summary>
            Round away from zero
            </summary>
        </member>
        <member name="F:IronRuby.StandardLibrary.BigDecimal.BigDecimal.RoundingModes.Down">
            <summary>
            Round toward zero
            </summary>
        </member>
        <member name="F:IronRuby.StandardLibrary.BigDecimal.BigDecimal.RoundingModes.HalfUp">
            <summary>
            Round towards "nearest neighbour" unless both neighbours are equidistant, in which case round up
            </summary>
        </member>
        <member name="F:IronRuby.StandardLibrary.BigDecimal.BigDecimal.RoundingModes.HalfDown">
            <summary>
            Round towards "nearest neighbour" unless both neighbours are equidistant, in which case round down
            </summary>
        </member>
        <member name="F:IronRuby.StandardLibrary.BigDecimal.BigDecimal.RoundingModes.Ceiling">
            <summary>
            Round toward positive infinity
            </summary>
        </member>
        <member name="F:IronRuby.StandardLibrary.BigDecimal.BigDecimal.RoundingModes.Floor">
            <summary>
            Round toward negative infinity
            </summary>
        </member>
        <member name="F:IronRuby.StandardLibrary.BigDecimal.BigDecimal.RoundingModes.HalfEven">
            <summary>
            Round towards "nearest neighbour" unless both neighbours are equidistant, in which case round to the even neighbour
            </summary>
        </member>
        <member name="T:IronRuby.StandardLibrary.BigDecimal.BigDecimal.OverflowExceptionModes">
            <summary>
            Flags of when exceptions should be thrown on special values
            </summary>
            <remarks>
            Currently Infinity, Overflow and ZeroDivide are the same
            </remarks>
        </member>
        <member name="M:IronRuby.StandardLibrary.BigDecimal.BigDecimal.CheckSpecialResult(IronRuby.StandardLibrary.BigDecimal.BigDecimal.Config,IronRuby.StandardLibrary.BigDecimal.BigDecimal,IronRuby.StandardLibrary.BigDecimal.BigDecimal,IronRuby.StandardLibrary.BigDecimal.BigDecimal.BasicOperations)">
            <summary>
            Look up special results for calculations that involve unusual values such as NaN, infinity and zero.
            </summary>
            <param name="x">The left hand side of the operation</param>
            <param name="y">The right hand side of the operation</param>
            <param name="op">The operation itself</param>
            <returns>The special result or null if the result is not special</returns>
        </member>
        <member name="F:IronRuby.StandardLibrary.BigDecimal.BigDecimal.SR">
            <remarks>
            Generated by the following ruby code
            <code>
              require 'bigdecimal'
              
              signs = [:-, :+]
              zeros = [true, false]
              types = [:NaN, :Finite, :Infinite]
              ops = [:+, :-, :*, :/]
              
              def CreateBigDecimal(sign, zero, type, finiteValue) 
                if zero
                  BigDecimal.new("#{sign}0.0")
                else
                  if type == :NaN
                    BigDecimal.new("NaN")
                  elsif type == :Infinite
                    BigDecimal.new("#{sign}Infinity")
                  else
                    BigDecimal.new("#{sign}#{finiteValue}")
                  end
                end
              end
              
              def map(r, null)
                 if r.sign == BigDecimal::SIGN_NaN
                   result = 'NaN'
                 elsif r.sign == BigDecimal::SIGN_POSITIVE_INFINITE
                   result = 'PositiveInfinity'
                 elsif r.sign == BigDecimal::SIGN_NEGATIVE_INFINITE
                   result = 'NegativeInfinity'
                 elsif r.sign == BigDecimal::SIGN_POSITIVE_ZERO
                   result = 'PositiveZero'
                 elsif r.sign == BigDecimal::SIGN_NEGATIVE_ZERO
                   result = 'NegativeZero'
                 elsif null
                   result = 'null'
                 else
                   result = 'Finite'
                 end
              end
              
              signs.each do |xSign|
              zeros.each do |xZero|
               types.each do |xType|
                 ops.each do |op|
                   signs.each do |ySign|
                     zeros.each do |yZero|
                       types.each do |yType|
                         x = CreateBigDecimal(xSign, xZero, xType, 7)
                         y = CreateBigDecimal(ySign, yZero, yType, 11)
                         r = x.send(op, y)
                         result = map(r, true)
                         puts "// #{map(x, false)} #{op} #{map(y, false)} = #{result}"
                         puts "SR[#{signs.index(xSign)}, #{zeros.index(xZero)}, #{types.index(xType)}, #{ops.index(op)}, #{signs.index(ySign)}, #{zeros.index(yZero)}, #{types.index(yType)}] = #{result};"
                       end
                     end
                   end
                 end
               end
              end
              end 
              </code>
            </remarks>
        </member>
        <member name="M:IronRuby.StandardLibrary.BigDecimal.Fraction.LimitPrecision(System.Int32,IronRuby.StandardLibrary.BigDecimal.Fraction,System.Int32,IronRuby.StandardLibrary.BigDecimal.BigDecimal.RoundingModes,System.Int32@)">
            <summary>
            Limits the precision of the given Fraction.
            </summary>
            <param name="sign">The sign of the BigDecimal</param>
            <param name="fraction">The fraction to limit</param>
            <param name="digits">The number of digits to which we are limiting</param>
            <param name="mode">The rounding mode to use when limiting</param>
            <returns>A new fraction that has no more than <paramref name="digits"/> digits.</returns>
            <example>
            Consider a fraction of 123456789 using default HalfUp rounding.
            Limit : Result
            1       1
            2       12
            3       123
            4       1234
            5       12346
            6       123457
            7       1234568
            8       12345679
            9       123456789
            10      123456789
            </example>
        </member>
        <member name="M:IronRuby.StandardLibrary.BigDecimal.Fraction.InternalDivide(System.UInt32[],System.Int32,System.UInt64,System.UInt32[],System.Int32,System.Int32,System.UInt32[])">
            <summary>
            Divide r[index, ...] by q
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.BigDecimal.Fraction.SubtractInPlace(System.UInt32[],System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Subtract y from x in place.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="T:IronRuby.StandardLibrary.Threading.ThreadOps">
            <summary>
            These methods are loaded only after doing "require 'thread'"
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.#ctor(IronRuby.Runtime.RubyContext)">
            <summary>
            Creates an uninitialized socket.
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.#ctor(IronRuby.Runtime.RubyContext,System.Net.Sockets.Socket)">
            <summary>
            Create a new RubyBasicSocket from a specified stream and mode
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.GetDoNotReverseLookup(IronRuby.Builtins.RubyClass)">
            <summary>
            Returns the value of the global reverse lookup flag.
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.SetDoNotReverseLookup(IronRuby.Builtins.RubyClass,System.Boolean)">
            <summary>
            Sets the value of the global reverse lookup flag.
            If set to true, queries on remote addresses will return the numeric address but not the host name.
            Defaults to false.
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.GetDoNotReverseLookup(IronRuby.StandardLibrary.Sockets.RubyBasicSocket)">
            <summary>
            Returns the value of the global reverse lookup flag.
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.SetDoNotReverseLookup(IronRuby.StandardLibrary.Sockets.RubyBasicSocket,System.Boolean)">
            <summary>
            Sets the value of the global reverse lookup flag.
            If set to true, queries on remote addresses will return the numeric address but not the host name.
            Defaults to false.
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.ForFileDescriptor">
            <summary>
            Wraps an already open file descriptor into a socket object.
            </summary>
            <returns>The corresponding socket</returns>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.SetSocketOption(IronRuby.Runtime.ConversionStorage{System.Int32},IronRuby.Runtime.RubyContext,IronRuby.StandardLibrary.Sockets.RubyBasicSocket,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets a socket option. These are protocol and system specific, see your local sytem documentation for details. 
            </summary>
            <param name="level">level is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level.</param>
            <param name="optname">optname is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR.</param>
            <param name="value">value is the value of the option, it is passed to the underlying setsockopt() as a pointer to a certain number of bytes. How this is done depends on the type.</param>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.SetSocketOption(IronRuby.Runtime.ConversionStorage{System.Int32},IronRuby.Runtime.RubyContext,IronRuby.StandardLibrary.Sockets.RubyBasicSocket,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets a socket option. These are protocol and system specific, see your local sytem documentation for details. 
            </summary>
            <param name="level">level is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level.</param>
            <param name="optname">optname is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR.</param>
            <param name="value">value is the value of the option, it is passed to the underlying setsockopt() as a pointer to a certain number of bytes. How this is done depends on the type.</param>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.SetSocketOption(IronRuby.Runtime.RubyContext,IronRuby.StandardLibrary.Sockets.RubyBasicSocket,System.Int32,System.Int32,IronRuby.Builtins.MutableString)">
            <summary>
            Sets a socket option. These are protocol and system specific, see your local sytem documentation for details. 
            </summary>
            <param name="context"></param>
            <param name="self"></param>
            <param name="level">level is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level.</param>
            <param name="optname">optname is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR.</param>
            <param name="value">value is the value of the option, it is passed to the underlying setsockopt() as a pointer to a certain number of bytes. How this is done depends on the type.</param>
            <example>
            Some socket options are integers with boolean values, in this case setsockopt could be called like this: 
            
              sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)
            Some socket options are integers with numeric values, in this case setsockopt could be called like this: 
            
              sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)
            Option values may be structs. Passing them can be complex as it involves examining your system headers to determine the correct definition. An example is an ip_mreq, which may be defined in your system headers as: 
            
              struct ip_mreq {
                struct  in_addr imr_multiaddr;
                struct  in_addr imr_interface;
              };
            In this case setsockopt could be called like this: 
            
              optval =  IPAddr.new("224.0.0.251") + Socket::INADDR_ANY
              sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)
            </example>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.GetSocketOption(IronRuby.Runtime.ConversionStorage{System.Int32},IronRuby.Runtime.RubyContext,IronRuby.StandardLibrary.Sockets.RubyBasicSocket,System.Int32,System.Int32)">
            <summary>
            Gets a socket option. These are protocol and system specific, see your local sytem documentation for details.
            </summary>
            <param name="level">level is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level.</param>
            <param name="optname">optname is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR.</param>
            <returns>The option is returned as a String with the data being the binary value of the socket option.</returns>
            <example>
            Some socket options are integers with boolean values, in this case getsockopt could be called like this: 
             optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)
             optval = optval.unpack "i"
             reuseaddr = optval[0] == 0 ? false : true
            Some socket options are integers with numeric values, in this case getsockopt could be called like this: 
             optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)
             ipttl = optval.unpack("i")[0]
            Option values may be structs. Decoding them can be complex as it involves examining your system headers to determine the correct definition. An example is a +struct linger+, which may be defined in your system headers as: 
              struct linger {
                int l_onoff;
                int l_linger;
              };
            In this case getsockopt could be called like this: 
              optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)
              onoff, linger = optval.unpack "ii"
            </example>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.ReceiveNonBlocking(IronRuby.Runtime.ConversionStorage{System.Int32},IronRuby.StandardLibrary.Sockets.RubyBasicSocket,System.Int32,System.Object)">
            <summary>
            Receives up to length bytes from socket using recvfrom after O_NONBLOCK is set for the underlying file descriptor.
            </summary>
            <param name="length">Maximum number of bytes to receive</param>
            <param name="flags">flags is zero or more of the MSG_ options.</param>
            <returns>The data received. When recvfrom(2) returns 0, Socket#recv_nonblock returns an empty string as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc. </returns>
            <example>
            serv = TCPServer.new("127.0.0.1", 0)
                 af, port, host, addr = serv.addr
                 c = TCPSocket.new(addr, port)
                 s = serv.accept
                 c.send "aaa", 0
                 IO.select([s])
                 p s.recv_nonblock(10) #=> "aaa"
            </example>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubyBasicSocket.IntegerAsFixnum(System.Object,System.Int32@)">
            <summary>
            Converts an Integer to a Fixnum.
            Don't call any conversion methods--just handles Fixnum and Bignum
            </summary>
            <param name="value"></param>
            <returns>true if value is an Integer, false otherwise</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws a RangeError if value is a
            BigInteger but can't be converted to a Fixnum</exception>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.IPSocket.#ctor(IronRuby.Runtime.RubyContext)">
            <summary>
            Creates an uninitialized socket.
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubySocket.CreateSocketPair(IronRuby.Builtins.RubyClass,System.Object,System.Object,System.Object)">
            <summary>
            Returns a pair of connected sockets
            [Not Implemented]
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubySocket.PackInetSockAddr(IronRuby.Runtime.ConversionStorage{IronRuby.Builtins.MutableString},IronRuby.Runtime.ConversionStorage{System.Int32},IronRuby.Builtins.RubyClass,System.Object,System.Object)">
            <summary>
            Returns the system dependent sockaddr structure packed into a string
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.RubySocket.UnPackInetSockAddr(IronRuby.Builtins.RubyClass,IronRuby.Builtins.MutableString)">
            <summary>
            Returns the system dependent sockaddr structure packed into a string
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.TCPServer.#ctor(IronRuby.Runtime.RubyContext)">
            <summary>
            Creates an uninitialized socket.
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.TCPSocket.#ctor(IronRuby.Runtime.RubyContext)">
            <summary>
            Creates an uninitialized socket.
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.Sockets.UDPSocket.#ctor(IronRuby.Runtime.RubyContext)">
            <summary>
            Creates an uninitialized socket.
            </summary>
        </member>
        <member name="T:IronRuby.StandardLibrary.Zlib.Zlib.Deflate.ZDeflateStream">
            <summary>
            Adds a 2 byte header, and a 4 byte adler checksum footer.
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.StringScanner.StringScanner.MustCVersion(System.Object)">
            <summary>
            This method is defined for backwards compatibility
            </summary>
        </member>
        <member name="M:IronRuby.StandardLibrary.ParseTree.IronRubyOps.ParseTreeOps.AstVisitor.AddRescueBody(IronRuby.Builtins.RubyArray,IronRuby.Compiler.Ast.Body)">
            <code>
            rescue
              2
            rescue A => e
              3
            rescue A,B => e
              4
            rescue A
              5
            rescue A,B
              6
            end
            
            [:resbody, 
                nil, 
                [:lit, 2], 
                [:resbody, 
                    [:array, [:const, :A]], 
                    [:block, 
                        [:lasgn, :e, [:gvar, :$!]], 
                        [:lit, 3]
                    ], 
                    [:resbody, 
                        [:array, [:const, :A], [:const, :B]], 
                        [:block, 
                            [:lasgn, :e, [:gvar, :$!]], 
                            [:lit, 4]
                        ], 
                        [:resbody, 
                            [:array, [:const, :A]], 
                            [:lit, 5], 
                            [:resbody, 
                                [:array, [:const, :A], [:const, :B]],
                                [:lit, 6]
                            ]
                        ]
                    ]
                ]
            ]
            </code>
        </member>
        <member name="P:IronRuby.StandardLibrary.Win32API.Win32API.DynamicModule">
            <summary>
            Gets the ModuleBuilder used to generate our unsafe call stubs into.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.ArgFilesSingletonOps">
            <summary>
            ARGF singleton trait.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.ArrayOps">
            <summary>
            Array inherits from Object, mixes in Enumerable.
            Ruby array is basically List{object}.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.BignumOps">
            <summary>
            Bignum objects hold integers outside the range of Fixnum. Bignum objects are created automatically when integer calculations would otherwise overflow a Fixnum. When a calculation involving Bignum objects returns a result that will fit in a Fixnum, the result is automatically converted. 
            For the purposes of the bitwise operations and [], a Bignum is treated as if it were an infinite-length bitstring with 2s complement representation. 
            While Fixnum values are immediate, Bignum objects are notassignment and parameter passing work with references to objects, not the objects themselves. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.BignumOps.Size(Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns the number of bytes in the machine representation of self. 
            </summary>
            <example>
               (256**10 - 1).size   #=> 12
               (256**20 - 1).size   #=> 20
               (256**40 - 1).size   #=> 40
            </example>
        </member>
        <member name="M:IronRuby.Builtins.Comparable.Compare(IronRuby.Runtime.ComparisonStorage,System.Object,System.Object)">
            <summary>
            Try to compare the lhs and rhs. Throws and exception if comparison returns null. Returns null on failure, -1/0/+1 otherwise.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RubyDir.ChangeDirectory(IronRuby.Runtime.ConversionStorage{IronRuby.Builtins.MutableString},IronRuby.Runtime.BlockParam,IronRuby.Builtins.RubyClass,System.Object)">
            <summary>
            raise a SystemCallError if the target directory does not exist
            </summary>
            <returns>0 if no block is given; otherwise, the value of the block</returns>
        </member>
        <member name="M:IronRuby.Builtins.RubyDir.ChangeDirectory(IronRuby.Runtime.BlockParam,IronRuby.Builtins.RubyClass)">
            <summary>
            change the directory to the value of the environment variable HOME or LOGDIR
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RubyDir.SetPosition(IronRuby.Builtins.RubyDir,System.Int32)">
            <summary>
            Synonym for Dir#seek, but returns the position parameter
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Enumerable.Map(IronRuby.Runtime.CallSiteStorage{System.Func{System.Runtime.CompilerServices.CallSite,System.Object,IronRuby.Builtins.Proc,System.Object}},IronRuby.Runtime.BlockParam,System.Object)">
            <summary>
            <code>
            def map
              result = []
              each do |*args|
                result.push yield(*args)
              end    
              result
            end
            </code>
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.Enumerator">
            <summary>
            A wrapper that provides "each" method for an arbitrary object. 
            A call to "each" on the instance of Enumerator is forwarded to a call to a method of a given name on the wrapped object.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.EnvironmentSingletonOps">
            <summary>
            ENV singleton trait.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.RubyFileOps">
            <summary>
            File builtin class. Derives from IO
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.RubyFileOps.RubyStatOps">
            <summary>
            Stat
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Int32Ops.ToSymbol(IronRuby.Runtime.RubyContext,System.Int32)">
            <summary>
            Returns the Symbol whose integer value is self
            <seealso cref="!:FixnumOps.id2name"/>
            </summary>
            <returns>Symbol or nil if there is no symbol with id of self</returns>
            <example>
            fred = :fred.to_i
            fred.id2name   #=> "fred"
            fred.to_sym    #=> :fred
            </example>
        </member>
        <member name="M:IronRuby.Builtins.Int32Ops.Id2Name(IronRuby.Runtime.RubyContext,System.Int32)">
            <summary>
            Returns the name of the object whose symbol id is self.
            </summary>
            <returns>MutableString or nil if there is no symbol with id of self.</returns>
            <example>
            symbol = :@inst_var    #=> :@inst_var
            id     = symbol.to_i   #=> 9818
            id.id2name             #=> "@inst_var"
            </example>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.EPSILON">
            <summary>
            Smallest Float such that 1.0+EPSILON != 1.0
            </summary>
            <remarks>System.Double.Epsilon is not actually the correct value!</remarks>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.MIN">
            <summary>
            The smallest Float greater than zero
            </summary>
            <remarks>
            Note this is not double.MinValue, which is most negative Float value.
            </remarks>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.MAX">
            <summary>
            The largest possible value for Float
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.DIG">
            <summary>
            The number of digits available in the mantissa (base 10)
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.MANT_DIG">
            <summary>
            The number of digits available in the mantissa (base 2)
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.MAX_10_EXP">
            <summary>
            The maximum size of the exponent (base 10)
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.MIN_10_EXP">
            <summary>
            The minimum size the the exponent (base 10)
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.MAX_EXP">
            <summary>
            The maximum size of the exponent (base 2)
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.MIN_EXP">
            <summary>
            The minimum size of the exponent (base 2)
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.RADIX">
            <summary>
            The radix or base of the mantissa
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.FloatOps.ROUNDS">
            <summary>
            Rounding mode used by Float
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.PrintOps">
            <summary>
            Mixin. Implements print, puts, putc methods.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.HashOps">
            <summary>
            Dictionary inherits from Object, mixes in Enumerable.
            Ruby hash is a Dictionary{object, object}, but it adds default value/proc
            
            TODO: Not all .NET types implement the right Equals, GetHashCode semantics (e.g. List{object})
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Integer.InducedFrom(IronRuby.Builtins.RubyClass,System.Int32)">
            <summary>
            Convert obj to an Integer, where obj is Fixnum
            </summary>
            <remarks>Just returns the Fixnum</remarks>
        </member>
        <member name="M:IronRuby.Builtins.Integer.InducedFrom(IronRuby.Builtins.RubyClass,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Convert obj to an Integer, where obj is Bignum
            </summary>
            <remarks>Just returns the Bignum</remarks>
        </member>
        <member name="M:IronRuby.Builtins.Integer.InducedFrom(IronRuby.Runtime.UnaryOpStorage,IronRuby.Builtins.RubyClass,System.Double)">
            <summary>
            Convert obj to an Integer, where obj is Float
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Integer.InducedFrom(IronRuby.Builtins.RubyClass,System.Object)">
            <summary>
            Convert obj to an Integer, where obj is not Fixnum, Bignum or Float
            </summary>
            <remarks>Just throws an error</remarks>
            <exception cref="T:System.InvalidOperationException">Assumption is object cannot be induced to Integer</exception>
        </member>
        <member name="M:IronRuby.Builtins.Integer.ToInteger(System.Object)">
            <summary>
            As self is already an Integer, just return self.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Integer.IsInteger(System.Object)">
            <summary>
            Always returns true.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:IronRuby.Builtins.Integer.Next(System.Int32)">
            <summary>
            Returns the Integer equal to self + 1, where self is Fixnum.
            </summary>
            <returns>May return Fixnum or Bignum depending on overflow/underflow.</returns>
            <example>
            1.next      #=> 2
            (-1).next   #=> 0
            </example>
        </member>
        <member name="M:IronRuby.Builtins.Integer.Next(IronRuby.Runtime.BinaryOpStorage,System.Object)">
            <summary>
            Returns the Integer equal to self + 1, where self is not Fixnum (probably Bignum).
            </summary>
            <returns>May return Fixnum or Bignum depending on overflow/underflow.</returns>
            <remarks>Dynamically invokes "+" operator to get next value.</remarks>
        </member>
        <member name="M:IronRuby.Builtins.Integer.Times(IronRuby.Runtime.BlockParam,System.Int32)">
            <summary>
            Iterates block self times, passing in values from zero to self - 1, where self is Fixnum.
            </summary>
            <returns>self</returns>
        </member>
        <member name="M:IronRuby.Builtins.Integer.Times(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BlockParam,System.Object)">
            <summary>
            Iterates block self times, passing in values from zero to self - 1, where self is not Fixnum (probably Bignum).
            </summary>
            <returns>self</returns>
            <remarks>
            Dynamically invokes "+" operator to find next item.
            Dynamically invokes "&lt;" operator to check if we have reached self - 1.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Integer.UpTo(IronRuby.Runtime.BlockParam,System.Int32,System.Int32)">
            <summary>
            Iterates block, passing in integer values from self up to and including other, where both self and other are Fixnum. 
            </summary>
            <returns>self</returns>
            <example>
               5.upto(10) { |i| print i, " " }
            produces: 
               5 6 7 8 9 10
            </example>
            <remarks>
            Since both self and other are Fixnum then this algorithm doesn't need to worry about overflowing into Bignum.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Integer.UpTo(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BlockParam,System.Object,System.Object)">
            <summary>
            Iterates block, passing in integer values from self up to and including other, where both self and other are Fixnum. 
            </summary>
            <returns>self</returns>
            <remarks>
            Dynamically invokes "+" operator to find next item down.
            Dynamically invokes "&gt;" operator and takes the negation to see if we have reached the bottom.
            This approach automatically deals with Floats and overflow/underflow between Fixnum and Bignum.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Integer.DownTo(IronRuby.Runtime.BlockParam,System.Int32,System.Int32)">
            <summary>
            Iterates block, passing decreasing values from self down to and including other, where both self and other are Fixnum.
            </summary>
            <returns>self</returns>
            <example>
            5.downto(1) { |n| print n, ".. " }
              print "  Liftoff!\n"
            produces: 
            5.. 4.. 3.. 2.. 1..   Liftoff!
            </example>
            <remarks>
            Since both self and other are Fixnum then this algorithm doesn't need to worry about overflowing into Bignum.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Integer.DownTo(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BlockParam,System.Object,System.Object)">
            <summary>
            Iterates block, passing decreasing values from self down to and including other, where other is not Fixnum (probably Bignum or Float).
            </summary>
            <returns>self</returns>
            <remarks>
            Dynamically invokes "-" operator to find next item down.
            Dynamically invokes "&lt;" operator and takes the negation to see if we have reached the bottom.
            This approach automatically deals with Floats and overflow/underflow between Fixnum and Bignum.
            </remarks>
        </member>
        <member name="T:IronRuby.Builtins.RubyIOOps">
            <summary>
            Implementation of IO builtin class. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.KernelOps.Inspect(IronRuby.Runtime.UnaryOpStorage,IronRuby.Runtime.ConversionStorage{IronRuby.Builtins.MutableString},System.Object)">
            <summary>
            Returns a string containing a human-readable representation of obj.
            If not overridden, uses the to_s method to generate the string. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.KernelOps.GetClrMember(IronRuby.Runtime.RubyContext,System.Object,System.Object,System.String)">
            <summary>
            Returns a RubyMethod instance that represents one or more CLR members of given name.
            An exception is thrown if the member is not found.
            Name could be of Ruby form (foo_bar) or CLR form (FooBar). Operator names are translated 
            (e.g. "+" to op_Addition, "[]"/"[]=" to a default index getter/setter).
            The resulting RubyMethod might represent multiple CLR members (overloads).
            Inherited members are included.
            Includes all CLR members that match the name even if they are not callable from Ruby - 
            they are hidden by a Ruby member or their declaring type is not included in the ancestors list of the class.
            Includes members of any Ruby visibility.
            Includes CLR protected members.
            Includes CLR private members if PrivateBinding is on.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.MutableStringOps.Ord(IronRuby.Builtins.MutableString)">
            <summary>
            Returns the first codepoint.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.UnaryPlus(System.Object)">
            <summary>
            Unary plus - returns the receivers value
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.UnaryMinus(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object)">
            <summary>
            Unary minus - returns the receivers value, negated.
            </summary>
            <remarks>
            Equivalent to:
            <code>
                c = 0.coerce(self);
                c[0] - c[1]
            </code>
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Compare(System.Object,System.Object)">
            <summary>
            Returns zero if self equals other (and is same type), nil otherwise. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Abs(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.UnaryOpStorage,System.Object)">
            <summary>
            Returns the absolute value of self
            </summary>
            <remarks>
            Dynamically invokes &lt; operator on self and 0
            If this is true then invokes @- on self.
            Otherwise just returns self
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Coerce(IronRuby.Runtime.ConversionStorage{System.Double},IronRuby.Runtime.ConversionStorage{System.Double},System.Object,System.Object)">
            <summary>
            If other is the same type as self, returns an array [other, self].
            Otherwise, returns an array [floatOther, floatSelf], whose elements are other and self represented as Float objects.
            </summary>
            <remarks>
            This coercion mechanism is used by Ruby to handle mixed-type numeric operations:
            It is intended to find a compatible common type between the two operands of the operator. 
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Div(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.ConversionStorage{System.Double},System.Object,System.Object)">
            <summary>
            Dynamically invokes / operator to perform division, then converts the result to an integer.
            </summary>
            <remarks>
            Numeric does not define the / operator; this is left to subclasses.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.DivMod(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.ConversionStorage{System.Double},System.Object,System.Object)">
            <summary>
            Returns an array [quotient, modulus] obtained by dividing self by other.
            The quotient is rounded toward -infinity.
            If q, r = x.divmod(y), then 
                q = floor(float(x)/float(y))
                x = q*y + r
            </summary>
            <remarks>
            The quotient is found by directly calling Numeric#div
            The modulus is found by dynamically invoking modulo method on self passing other.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Eql(IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns true if num and numeric are the same type and have equal values. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Round(System.Double)">
            <summary>
            Rounds self to the nearest integer.
            </summary>
            <remarks>
            This is achieved by converting self to a Float and directly calling Float#round.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Floor(System.Double)">
            <summary>
            Returns the largest integer less than or equal to self.
            </summary>
            <remarks>
            This is achieved by converting self to a Float and directly calling Float#floor. 
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Ceil(System.Double)">
            <summary>
            Returns the smallest Integer greater than or equal to num.
            </summary>
            <remarks>
            This is achieved by converting self to a Float then directly calling Float#ceil.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Truncate(System.Double)">
            <summary>
            Returns self truncated to an integer.
            </summary>
            <remarks>
            This is achieved by converting self to a float and directly calling Float#truncate. 
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.IsInteger(System.Object)">
            <summary>
            Returns true if self is an Integer (i.e. Fixnum or Bignum).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Modulo(IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Equivalent to self.divmod(other)[1]
            </summary>
            <remarks>
            This is achieved by dynamically invoking % operator on self and other.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.IsNonZero(IronRuby.Runtime.UnaryOpStorage,System.Object)">
            <summary>
            Returns num if num is not zero, nil otherwise.
            </summary>
            <example>
            This behavior is useful when chaining comparisons: 
                a = %w( z Bb bB bb BB a aA Aa AA A )
                b = a.sort {|a,b| (a.downcase &lt;=&gt; b.downcase).nonzero? || a &lt;=&gt; b }
                b   #=> ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]
            </example>
            <remarks>
            This is achieved by dynamically invoking IsZero on self;
            returning nil if it is or self otherwise.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Quo(IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Equivalent to invoking Numeric#/; overridden in subclasses
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Remainder(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            If self and other have different signs, returns (self.modulo(other)-other;
            otherwise, returns self.modulo(other).
            </summary>
            <remarks>
            This is achieved by dynamically invoking modulo on self;
            then invoking &lt; operator on the self and other against 0.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Step(IronRuby.Runtime.BlockParam,System.Int32,System.Int32)">
            <summary>
            Invokes block with the sequence of numbers starting at self, incremented by step on each call.
            The loop finishes when the value to be passed to the block is greater than limit (if step is positive) or less than limit (if step is negative).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Step(IronRuby.Runtime.BlockParam,System.Int32,System.Int32,System.Int32)">
            <summary>
            Invokes block with the sequence of numbers starting at self, incremented by step on each call.
            The loop finishes when the value to be passed to the block is greater than limit (if step is positive) or less than limit (if step is negative).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Step(IronRuby.Runtime.BlockParam,System.Double,System.Double,System.Double)">
            <summary>
            Invokes block with the sequence of numbers starting at self, incremented by step on each call.
            The loop finishes when the value to be passed to the block is greater than limit (if step is positive) or less than limit (if step is negative).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.Step(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.ConversionStorage{System.Double},IronRuby.Runtime.BlockParam,System.Object,System.Object,System.Object)">
            <summary>
            Invokes block with the sequence of numbers starting at self, incremented by step on each call.
            The loop finishes when the value to be passed to the block is greater than limit (if step is positive) or less than limit (if step is negative).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.ToInt(IronRuby.Runtime.UnaryOpStorage,System.Object)">
            <summary>
            Invokes the self.to_i method to convert self to an integer.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Numeric.IsZero(IronRuby.Runtime.BinaryOpStorage,System.Object)">
            <summary>
            Returns true if self has a zero value. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Precision.Prec(IronRuby.Runtime.CallSiteStorage{System.Func{System.Runtime.CompilerServices.CallSite,IronRuby.Builtins.RubyClass,System.Object,System.Object}},System.Object,IronRuby.Builtins.RubyClass)">
            <summary>
            Converts self into an instance of klass.
            </summary>
            <remarks>
            By default, prec invokes klass.induced_from(self) and returns its value.
            So, if <code>klass.induced_from</code> doesn't return an instance of klass, it will be necessary to reimplement prec.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.Precision.PrecInteger(IronRuby.Runtime.CallSiteStorage{System.Func{System.Runtime.CompilerServices.CallSite,System.Object,IronRuby.Builtins.RubyClass,System.Object}},System.Object)">
            <summary>
            Returns an Integer converted from self. It is equivalent to <code>prec(Integer)</code>.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Precision.PrecFloat(IronRuby.Runtime.CallSiteStorage{System.Func{System.Runtime.CompilerServices.CallSite,System.Object,IronRuby.Builtins.RubyClass,System.Object}},System.Object)">
            <summary>
            Returns a Float converted from self. It is equivalent to <code>prec(Float)</code>.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Precision.Included(IronRuby.Runtime.RubyContext,IronRuby.Builtins.RubyModule,IronRuby.Builtins.RubyModule)">
            <summary>
            When the Precision module is mixed-in to a class, via the Module#include method, this included method is called.
            Here it is used to add our default induced_from implementation to the host class.
            </summary>
            <param name="context"></param>
            <param name="self">The module being mixed in.</param>
            <param name="includedIn">The host class including the module</param>
        </member>
        <member name="T:IronRuby.Builtins.RubyPipe">
            <summary>
            Pipe for intra-process producer-consumer style message passing
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.RubyPipe.PipeWriter">
            <summary>
            PipeWriter instance always exists as a sibling of a RubyPipe. Two objects are needed
            so that we can detect whether Close is being called on the reader end of a pipe,
            or on the writer end of a pipe.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.RubyProcess">
            <summary>
            Process builtin module
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RubyStructOps.Create(IronRuby.Runtime.BlockParam,IronRuby.Builtins.RubyClass,System.String,System.String[])">
            <summary>
            Struct#new
            Creates Struct classes with the specified name and members
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.RangeOps">
            <summary>
            A Range represents an intervala set of values with a start and an end.
            Ranges may be constructed using the s..e and se literals, or with Range::new.
            Ranges constructed using .. run from the start to the end inclusively.
            Those created using  exclude the end value.
            When used as an iterator, ranges return each value in the sequence. 
            </summary>
            <example>
               (-1..-5).to_a      #=> []
               (-5..-1).to_a      #=> [-5, -4, -3, -2, -1]
               ('a'..'e').to_a    #=> ["a", "b", "c", "d", "e"]
               ('a'...'e').to_a   #=> ["a", "b", "c", "d"]
            </example>
            <remarks>
            Ranges can be constructed using objects of any type, as long as the objects can be compared using their &lt;=&gt; operator
            and they support the succ method to return the next object in sequence. 
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.CreateRange(IronRuby.Runtime.BinaryOpStorage,IronRuby.Builtins.RubyClass,System.Object,System.Object,System.Boolean)">
            <summary>
            Construct a new Range object.
            </summary>
            <returns>
            An empty Range object
            </returns>
            <remarks>
            This constructor only creates an empty range object,
            which will be initialized subsequently by a separate call through into one of the two initialize methods.
            Literal Ranges (e.g. 1..5, 'a'...'b' are created by calls through to RubyOps.CreateInclusiveRange and
            RubyOps.CreateExclusiveRange which bypass this constructor/initializer run about and initialize the object directly.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.Begin(IronRuby.Builtins.Range)">
            <summary>
            Returns the first object in self
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.End(IronRuby.Builtins.Range)">
            <summary>
            Returns the object that defines the end of self
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.ExcludeEnd(IronRuby.Builtins.Range)">
            <summary>
            Returns true if self excludes its end value. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.Inspect(IronRuby.Runtime.RubyContext,IronRuby.Builtins.Range)">
            <summary>
            Convert this range object to a printable form (using inspect to convert the start and end objects). 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.ToS(IronRuby.Runtime.ConversionStorage{IronRuby.Builtins.MutableString},IronRuby.Builtins.Range)">
            <summary>
            Convert this range object to a printable form (using to_s to convert the start and end objects).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.Equals(IronRuby.Builtins.Range,System.Object)">
            <summary>
            Is other equal to self?  Here other is not a Range so returns false.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.Equals(IronRuby.Runtime.BinaryOpStorage,IronRuby.Builtins.Range,IronRuby.Builtins.Range)">
            <summary>
            Returns true only if self is a Range, has equivalent beginning and end items (by comparing them with ==),
            and has the same exclude_end? setting as <i>other</i>. 
            </summary>
            <example>
            (0..2) == (0..2)            #=> true
            (0..2) == Range.new(0,2)    #=> true
            (0..2) == (0...2)           #=> false
            (0..2).eql?(0.0..2.0)       #=> true
            </example>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.Eql(IronRuby.Runtime.BinaryOpStorage,IronRuby.Builtins.Range,IronRuby.Builtins.Range)">
            <summary>
            Returns true only if self is a Range, has equivalent beginning and end items (by comparing them with eql?),
            and has the same exclude_end? setting as <i>other</i>. 
            </summary>
            <example>
            (0..2).eql?(0..2)             #=> true
            (0..2).eql?(Range.new(0,2))   #=> true
            (0..2).eql?(0...2)            #=> false
            (0..2).eql?(0.0..2.0)         #=> false
            </example>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.CaseEquals(IronRuby.Runtime.ComparisonStorage,IronRuby.Builtins.Range,System.Object)">
            <summary>
            Returns true if other is an element of self, false otherwise.
            Conveniently, === is the comparison operator used by case statements. 
            </summary>
            <example>
            case 79
              when 1..50   then   print "low\n"
              when 51..75  then   print "medium\n"
              when 76..100 then   print "high\n"
            end
            => "high"
            </example>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.GetHashCode(IronRuby.Runtime.UnaryOpStorage,IronRuby.Builtins.Range)">
            <summary>
            Generate a hash value such that two ranges with the same start and end points,
            and the same value for the "exclude end" flag, generate the same hash value. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.Each(IronRuby.Builtins.RangeOps.EachStorage,IronRuby.Runtime.BlockParam,IronRuby.Builtins.Range)">
            <summary>
            Iterates over the elements of self, passing each in turn to the block.
            You can only iterate if the start object of the range supports the succ method
            (which means that you cant iterate over ranges of Float objects). 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.Step(IronRuby.Builtins.RangeOps.StepStorage,IronRuby.Runtime.BlockParam,IronRuby.Builtins.Range,System.Object)">
            <summary>
            Iterates over self, passing each stepth element to the block.
            If the range contains numbers or strings, natural ordering is used.
            Otherwise step invokes succ to iterate through range elements.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.StepFixnum(IronRuby.Runtime.BlockParam,IronRuby.Builtins.Range,System.Int32,System.Int32,System.Int32)">
            <summary>
            Step through a Range of Fixnums.
            </summary>
            <remarks>
            This method is optimized for direct integer operations using &lt; and + directly.
            It is not used if either begin or end are outside Fixnum bounds.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.StepString(IronRuby.Builtins.RangeOps.EachStorage,IronRuby.Runtime.BlockParam,IronRuby.Builtins.Range,IronRuby.Builtins.MutableString,IronRuby.Builtins.MutableString,System.Int32)">
            <summary>
            Step through a Range of Strings.
            </summary>
            <remarks>
            This method requires step to be a Fixnum.
            It uses a hybrid string comparison to prevent infinite loops and calls String#succ to get each item in the range.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.StepNumeric(IronRuby.Builtins.RangeOps.StepStorage,IronRuby.Runtime.BlockParam,IronRuby.Builtins.Range,System.Object,System.Object,System.Object)">
            <summary>
            Step through a Range of Numerics.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.StepObject(IronRuby.Builtins.RangeOps.EachStorage,IronRuby.Runtime.BlockParam,IronRuby.Builtins.Range,System.Object,System.Object,System.Int32)">
            <summary>
            Step through a Range of objects that are not Numeric or String.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.CheckStep(System.Int32)">
            <summary>
            Check that the int is not less than or equal to zero.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.CheckStep(IronRuby.Builtins.RangeOps.EachStorage,System.Object)">
            <summary>
            Check that the object, when converted to an integer, is not less than or equal to zero.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RangeOps.CheckBegin(IronRuby.Builtins.RangeOps.EachStorage,System.Object)">
            <summary>
            Check that the object responds to "succ".
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RegexpOps.ToS(IronRuby.Builtins.RubyRegex)">
            <summary>
            Returns "(?{enabled-options}-{disabled-options}:{pattern-with-forward-slash-escaped})".
            Doesn't escape forward slashes that are already escaped.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RegexpOps.Inspect(IronRuby.Builtins.RubyRegex)">
            <summary>
            Returns "/{pattern-with-forward-slash-escaped}/"
            Doesn't escape forward slashes that are already escaped.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Signal.Trap(IronRuby.Runtime.RubyContext,System.Object,System.Object,IronRuby.Builtins.Proc)">
            <summary>
            Registers an interrupt handler. The host application is responsible for ensuring
            that the handler will actually be called.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.Signal.Trap(IronRuby.Runtime.RubyContext,IronRuby.Runtime.BlockParam,System.Object,System.Object)">
            <summary>
            Registers an interrupt handler. The host application is responsible for ensuring
            that the handler will actually be called.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.MainSingletonOps">
            <summary>
            Methods on Singleton(main).
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.StringFormatter">
            <summary>
            StringFormatter provides Ruby's sprintf style string formatting services.
            
            TODO: Many dynamic languages have similar printf style functionality.
                  Combine this with IronPython's StringFormatter and move the common code into the DLR
            
            TODO: Support negative numbers for %u and %o and %x
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.StringFormatter._buf">
            TODO: Use MutableString instead of StringBuilder for building the string + encodings
        </member>
        <member name="M:IronRuby.Builtins.StringFormatter.AppendBase(System.Char,System.Int32)">
            <summary>
            AppendBase appends an integer at the specified radix doing all the
            special forms for Ruby.  We have a copy and paste version of this
            for BigInteger below that should be kept in sync.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.ThreadOps">
            <summary>
            Ruby threads are represented by CLR thread objects (System.Threading.Thread).
            Ruby 1.8.N has green threads where the language does the thread scheduling. We map the green threads 
            directly to CLR threads.
            
            Ruby supports asynchronously manipulating of an arbitrary thread with methods like Thread#raise, Thread#exit, etc.
            For such methods, we use Thread.Abort which is unsafe. Howevever, Ruby 1.9 may not support green threads,
            and this will not be an issue then.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.ThreadOps.RubyThreadStatus">
            <summary>
            The ThreadState enumeration is a flag, and multiple values could be set simultaneously. Also,
            there is other state that IronRuby tracks. RubyThreadStatus flattens out the different states
            into non-overlapping values.
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.ThreadOps.RubyThreadStatus.Unstarted">
            <summary>
            Ruby does not expose such a state. However, since IronRuby uses CLR threads, this state can exist for
            threads that are not created directly from Ruby code
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.ThreadOps.RubyThreadStatus.Aborting">
            <summary>
            If Thread#kill has been called, and the thread is not sleeping
            </summary>
        </member>
        <member name="F:IronRuby.Builtins.ThreadOps.RubyThreadStatus.Aborted">
            <summary>
            An unhandled exception was thrown by the thread
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ThreadOps.RubyThreadInfo.Sleep">
            <summary>
            We do not use Thread.Sleep here as another thread can call Thread#wakeup/Thread#run. Instead, we use our own
            lock which can be signalled from another thread.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.RubyEncoder.WritePrintedQuotable(System.IO.Stream,IronRuby.Builtins.MutableString,System.Int32)">
            <summary>
            Printable characters: [33, 60], [62, 126], space (32), tab (9) but not at the end of line
            Escaped: others =XX
            Soft eolns (could be inserted anywhere, Ruby: after each count + 1 characters): =\n
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.ClrBigInteger">
            <summary>
            Mixed-in all .NET numeric primitive types that cannot be widened to 32 bit signed integer.
            (uint, long, ulong, BigInteger). 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Negate(Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Unary minus (returns a new Bignum whose value is 0-self)
            </summary>
            <returns>0 minus self</returns>
            <remarks>Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Abs(Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns the absolute value of self
            </summary>
            <returns>self if self >= 0; -self if self &lt; 0</returns>
            <remarks>Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Add(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Adds self and other, where other is Bignum or Fixnum
            </summary>
            <returns>self + other</returns>
            <remarks>Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Add(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Adds self and other, where other is Bignum or Fixnum
            </summary>
            <returns>self + other</returns>
            <remarks>Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Add(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Adds self and other, where other is Float
            </summary>
            <returns>self + other as Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Add(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Adds self and other, where other is not a Float, Fixnum or Bignum
            </summary>
            <returns>self + other</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes +</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Subtract(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Subtracts other from self, where other is Bignum or Fixnum
            </summary>
            <returns>self - other</returns>
            <remarks>Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Subtract(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Subtracts other from self, where other is Bignum or Fixnum
            </summary>
            <returns>self - other</returns>
            <remarks>Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Subtract(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Subtracts other from self, where other is Float
            </summary>
            <returns>self - other as Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Subtract(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Subtracts other from self, where other is not a Float, Fixnum or Bignum
            </summary>
            <returns>self - other</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes -</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Multiply(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Multiplies self by other, where other is Bignum or Fixnum
            </summary>
            <returns>self * other</returns>
            <remarks>Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Multiply(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Multiplies self by other, where other is Bignum or Fixnum
            </summary>
            <returns>self * other</returns>
            <remarks>Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Multiply(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Multiplies self by other, where other is Float
            </summary>
            <returns>self * other as Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Multiply(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Multiplies self by other, where other is not a Float, Fixnum or Bignum
            </summary>
            <returns>self * other</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes *</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Divide(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Divides self by other, where other is Bignum or Fixnum
            </summary>
            <returns>self / other</returns>
            <remarks>Uses DivMod to do the division (directly).  Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Divide(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Divides self by other, where other is Bignum or Fixnum
            </summary>
            <returns>self / other</returns>
            <remarks>Uses DivMod to do the division (directly).  Normalizes to a Fixnum if necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.DivideOp(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Divides self by other, where other is Float
            </summary>
            <returns>self / other as Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Divide(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Divides self by other, where other is Float
            </summary>
            <returns>self divided by other as Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Divide(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Divides self by other, where other is not a Float, Fixnum or Bignum
            </summary>
            <returns>self / other</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes /</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Div(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Divides self by other, where other is not a Float, Fixnum or Bignum
            </summary>
            <returns>self.div(other)</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes div</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Quotient(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns the floating point result of dividing self by other, where other is Bignum or Fixnum. 
            </summary>
            <returns>self divided by other as Float</returns>
            <remarks>Converts self and other to Float and then divides.</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Quotient(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Returns the floating point result of dividing self by other, where other is Bignum or Fixnum. 
            </summary>
            <returns>self divided by other as Float</returns>
            <remarks>Converts self and other to Float and then divides.</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Quotient(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Returns the floating point result of dividing self by other, where other is Float. 
            </summary>
            <returns>self divided by other as Float</returns>
            <remarks>Converts self to Float and then divides.</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Quotient(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns the floating point result of dividing self by other, where other is not Bignum, Fixnum or Float. 
            </summary>
            <returns>self divided by other as Float</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes quo</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Power(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Raises self to the exponent power, where exponent is Bignum.
            </summary>
            <returns>self ** exponent as Float </returns>
            <remarks>Converts self and exponent to Float (directly) and then calls System.Math.Pow</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Power(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Raises self to the exponent power, where exponent is Fixnum
            </summary>
            <returns>self ** exponent</returns>
            <remarks>
            Returns Bignum or Fixnum if exponent &gt;= 0.
            Returns Float if exponent &lt; 0
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Power(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Raises self to the exponent power, where exponent is Float
            </summary>
            <returns>self ** exponent as Float</returns>
            <remarks>Converts self to Float (directly) then calls System.Math.Pow</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Power(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Raises self to the exponent power, where exponent is not Fixnum, Bignum or Float
            </summary>
            <returns>self ** exponent</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes **</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Modulo(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns self modulo other, where other is Fixnum or Bignum.
            </summary>
            <returns>self modulo other, as Fixnum or Bignum</returns>
            <remarks>Calls divmod directly to get the modulus.</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Modulo(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Returns self modulo other, where other is Fixnum or Bignum.
            </summary>
            <returns>self modulo other, as Fixnum or Bignum</returns>
            <remarks>Calls divmod directly to get the modulus.</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Modulo(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Returns self modulo other, where other is Float.
            </summary>
            <returns>self modulo other, as Float</returns>
            <remarks>Calls divmod directly to get the modulus.</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.ModuloOp(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns self % other, where other is not Fixnum or Bignum.
            </summary>
            <returns>self % other, as Fixnum or Bignum</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes %</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Modulo(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns self modulo other, where other is not Fixnum or Bignum.
            </summary>
            <returns>self modulo other, as Fixnum or Bignum</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes modulo</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.DivMod(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns an array containing the quotient and modulus obtained by dividing self by other, where other is Fixnum or Bignum.
            If <code>q, r = x.divmod(y)</code>, then 
                <code>q = floor(float(x)/float(y))</code>
                <code>x = q*y + r</code>
            </summary>
            <returns>[self div other, self modulo other] as RubyArray</returns>
            <remarks>Normalizes div and mod to Fixnum as necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.DivMod(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Returns an array containing the quotient and modulus obtained by dividing self by other, where other is Fixnum or Bignum.
            If <code>q, r = x.divmod(y)</code>, then 
                <code>q = floor(float(x)/float(y))</code>
                <code>x = q*y + r</code>
            </summary>
            <returns>[self div other, self modulo other] as RubyArray</returns>
            <remarks>Normalizes div and mod to Fixnum as necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.DivMod(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Returns an array containing the quotient and modulus obtained by dividing self by other, where other is Float.
            If <code>q, r = x.divmod(y)</code>, then 
                <code>q = floor(float(x)/float(y))</code>
                <code>x = q*y + r</code>
            </summary>
            <returns>[self div other, self modulo other] as RubyArray</returns>
            <remarks>Normalizes div to Fixnum as necessary</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.DivMod(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns an array containing the quotient and modulus obtained by dividing self by other, where other is not Fixnum or Bignum.
            If <code>q, r = x.divmod(y)</code>, then 
                <code>q = floor(float(x)/float(y))</code>
                <code>x = q*y + r</code>
            </summary>
            <returns>Should return [self div other, self modulo other], but the divmod implementation is free to return an arbitrary object.</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes divmod</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Remainder(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns the remainder after dividing self by other, where other is Fixnum or Bignum.
            </summary>
            <example>
            -1234567890987654321.remainder(13731)      #=> -6966
            </example>
            <returns>Fixnum or Bignum</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Remainder(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Returns the remainder after dividing self by other, where other is Fixnum or Bignum.
            </summary>
            <example>
            -1234567890987654321.remainder(13731)      #=> -6966
            </example>
            <returns>Fixnum or Bignum</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Remainder(Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Returns the remainder after dividing self by other, where other is Float.
            </summary>
            <example>
            -1234567890987654321.remainder(13731.24)   #=> -9906.22531493148
            </example>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Remainder(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns the remainder after dividing self by other, where other is not Fixnum or Bignum.
            </summary>
            <example>
            -1234567890987654321.remainder(13731)      #=> -6966
            </example>
            <returns>Fixnum or Bignum</returns>
            <remarks>Coerces self and other using other.coerce(self) then dynamically invokes remainder</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Compare(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Comparison operator, where other is Bignum or Fixnum. This is the basis for the tests in Comparable.
            </summary>
            <returns>
            Returns -1, 0, or +1 depending on whether self is less than, equal to, or greater than other.
            </returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Compare(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Comparison operator, where other is Bignum or Fixnum. This is the basis for the tests in Comparable.
            </summary>
            <returns>
            Returns -1, 0, or +1 depending on whether self is less than, equal to, or greater than other.
            </returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Compare(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Comparison operator, where other is Float. This is the basis for the tests in Comparable.
            </summary>
            <returns>
            Returns -1, 0, or +1 depending on whether self is less than, equal to, or greater than other.
            </returns>
            <remarks>
            Converts self to Float and then directly invokes &lt;=&gt;.
            Correctly copes if self is too big to fit into a Float, i.e. assumes self is +/-Infinity.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Compare(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,Microsoft.Scripting.Math.BigInteger,System.Object)">
            <summary>
            Comparison operator, where other is not Bignum, Fixnum or Float. This is the basis for the tests in Comparable.
            </summary>
            <returns>
            Returns -1, 0, or +1 depending on whether self is less than, equal to, or greater than other.
            </returns>
            <remarks>
            Dynamically invokes &lt;=&gt;.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Equal(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns true if other has the same value as self, where other is Fixnum or Bignum.
            Contrast this with Bignum#eql?, which requires other to be a Bignum.
            </summary>
            <returns>true or false</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Equal(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Returns true if other has the same value as self, where other is Fixnum or Bignum.
            Contrast this with Bignum#eql?, which requires other to be a Bignum.
            </summary>
            <returns>true or false</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Equal(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger,System.Double)">
            <summary>
            Returns true if other has the same value as self, where other is Float.
            Contrast this with Bignum#eql?, which requires other to be a Bignum.
            </summary>
            <returns>true or false</returns>
            <remarks>Returns false if other is NaN.</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Equal(IronRuby.Runtime.BinaryOpStorage,Microsoft.Scripting.Math.BigInteger,System.Object)">
            <summary>
            Returns true if other has the same value as self, where other is not Fixnum, Bignum or Float.
            Contrast this with Bignum#eql?, which requires other to be a Bignum.
            </summary>
            <returns>true or false</returns>
            <remarks>Dynamically invokes other == self (i.e. swaps self and other around)</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Eql(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns true only if other is a Bignum with the same value as self.
            Contrast this with Bignum#==, which performs type conversions. 
            </summary>
            <returns>true if other is Bignum and self == other</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Eql(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Returns true only if other is a Bignum with the same value as self, where other is Fixnum.
            Contrast this with Bignum#==, which performs type conversions. 
            </summary>
            <returns>false</returns>
            <remarks>
            Always returns false since other is not Bignum.
            This overload is necessary otherwise the int will be implicitly cast to BigInteger,
            even though it should always then return false in that case since other should
            be too small to be equal to self, it is just a waste of a conversion.</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Eql(Microsoft.Scripting.Math.BigInteger,System.Object)">
            <summary>
            Returns true only if other is a Bignum with the same value as self, where other is not Bignum or Fixnum.
            Contrast this with Bignum#==, which performs type conversions. 
            </summary>
            <returns>false</returns>
            <remarks>Always returns false since other is not Bignum</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.LeftShift(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Shifts self to the left by other bits (or to the right if other is negative).
            </summary>
            <returns>self &lt;&lt; other, as Bignum or Fixnum</returns>
            <remarks>
            If self is negative we have to check for running out of bits, in which case we return -1.
            This is because Bignum is supposed to look like it is stored in 2s complement format.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.LeftShift(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger,IronRuby.Runtime.IntegerValue)">
            <summary>
            Shifts self to the left by other bits (or to the right if other is negative).
            </summary>
            <returns>self &lt;&lt; other, as Bignum or Fixnum</returns>
            <remarks>other is converted to an Integer by dynamically invoking self.to_int</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.RightShift(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Shifts self to the right by other bits (or to the left if other is negative).
            </summary>
            <returns>self >> other, as Bignum or Fixnum</returns>
            <remarks>
            If self is negative we have to check for running out of bits, in which case we return -1.
            This is because Bignum is supposed to look like it is stored in 2s complement format.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.RightShift(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger,IronRuby.Runtime.IntegerValue)">
            <summary>
            Shifts self to the left by other bits (or to the right if other is negative).
            </summary>
            <returns>self >> other, as Bignum or Fixnum</returns>
            <remarks>other is converted to an Integer by dynamically invoking self.to_int</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.BitwiseOr(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger,IronRuby.Runtime.IntegerValue)">
            <summary>
            Performs bitwise or between self and other, where other is not Fixnum or Bignum. 
            </summary>
            <remarks>other is dynamically converted to an Integer by other.to_int then | is invoked dynamically. E.g. self | (index.to_int)</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.And(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger,IronRuby.Runtime.IntegerValue)">
            <summary>
            Performs bitwise and between self and other, where other is not Fixnum or Bignum. 
            </summary>
            <remarks>other is dynamically converted to an Integer by other.to_int then "&amp;" is invoked dynamically. E.g. self &amp; (index.to_int)</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Xor(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger,IronRuby.Runtime.IntegerValue)">
            <summary>
            Performs bitwise xor between self and other, where other is not Fixnum or Bignum. 
            </summary>
            <remarks>other is dynamically converted to an Integer by other.to_int then ^ is invoked dynamically. E.g. self ^ (index.to_int)</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Invert(Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Performs bitwise inversion on self.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Bit(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Returns the Bit value at the reference index, where index is Fixnum
            </summary>
            <example>
            <code>
              a = 9**15
              50.downto(0) do |n|
                print a[n]
              end
            </code>
            produces: 
            <code>
              000101110110100000111000011110010100111100010111001
            </code>
            </example>
            <returns>indexth bit in the (assumed) binary representation of self, where self[0] is the least significant bit.</returns>
            <remarks>Since representation is supposed to be 2s complement, we return always 1 if self is negative and index is greater than most signifcant bit in BigInteger</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Bit(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns the Bit value at the reference index, where index is Bignum
            </summary>
            <returns>
            0 if index is negative or self is positive
            1 otherwise
            </returns>
            <remarks>
            Since representation is supposed to be 2s complement and index must be extremely big,
            we asssume we can always return 1 if self is negative and 0 otherwise</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.ToFloat(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Converts self to a Float. If self doesnt fit in a Float, the result is infinity. 
            </summary>
            <returns>self as a Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.ToString(Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns a string containing the representation of self base 10.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.ToString(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Returns a string containing the representation of self base radix (2 through 36).
            </summary>
            <param name="radix">An integer between 2 and 36 inclusive</param>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Coerce(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Attempts to coerce other to a Bignum.
            </summary>
            <returns>[other, self] as Bignums</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Coerce(IronRuby.Runtime.RubyContext,Microsoft.Scripting.Math.BigInteger,System.Object)">
            <summary>
            Attempts to coerce other to a Bignum, where other is not Fixnum or Bignum.
            </summary>
            <exception cref="T:System.InvalidOperationException">For any value of other.</exception>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.Hash(Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Compute a hash based on the value of self. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrBigInteger.ShiftOverflowCheck(Microsoft.Scripting.Math.BigInteger,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Test for shift overflow on negative BigIntegers
            </summary>
            <param name="self">Value before shifting</param>
            <param name="result">Value after shifting</param>
            <returns>-1 if we overflowed, otherwise result</returns>
            <remarks>
            Negative Bignums are supposed to look like they are stored in 2s complement infinite bit string, 
            a negative number should always have spare 1s available for on the left hand side for right shifting.
            E.g. 8 == ...0001000; -8 == ...1110111, where the ... means that the left hand value is repeated indefinitely.
            The test here checks whether we have overflowed into the infinite 1s.
            [Arguably this should get factored into the BigInteger class.]
            </remarks>
        </member>
        <member name="T:IronRuby.Builtins.ClrFloat">
            <summary>
            Mixed-in .NET floating point numeric primitive types (float, double).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.InducedFrom(IronRuby.Builtins.RubyModule,System.Double)">
            <summary>
            Convert value to Float, where value is Float.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.InducedFrom(IronRuby.Runtime.UnaryOpStorage,IronRuby.Builtins.RubyModule,System.Int32)">
            <summary>
            Convert value to Float, where value is Fixnum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.InducedFrom(IronRuby.Runtime.UnaryOpStorage,IronRuby.Builtins.RubyModule,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Convert value to Float, where value is Bignum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.InducedFrom(IronRuby.Builtins.RubyModule,System.Object)">
            <summary>
            Convert value to Float, where value is not Float, Fixnum or Bignum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Multiply(System.Double,System.Int32)">
            <summary>
            Returns a new float which is the product of <code>self</code> * and <code>other</code>, where <code>other</code> is Fixnum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Multiply(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns a new float which is the product of <code>self</code> * and <code>other</code>, where <code>other</code> is Bignum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Multiply(System.Double,System.Double)">
            <summary>
            Returns a new float which is the product of <code>self</code> * and <code>other</code>, where <code>other</code> is Float.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Multiply(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns a new float which is the product of <code>self</code> * and <code>other</code>, , where <code>other</code> is not Fixnum, Bignum or Float.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Add(System.Double,System.Int32)">
            <summary>
            Returns a new float which is the sum of <code>self</code> * and <code>other</code>, where <code>other</code> is Fixnum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Add(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns a new float which is the sum of <code>self</code> * and <code>other</code>, where <code>other</code> is Bignum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Add(System.Double,System.Double)">
            <summary>
            Returns a new float which is the sum of <code>self</code> * and <code>other</code>, where <code>other</code> is Float.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Add(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns a new float which is the sum of <code>self</code> * and <code>other</code>, , where <code>other</code> is not Fixnum, Bignum or Float.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Subtract(System.Double,System.Int32)">
            <summary>
            Returns a new float which is the difference between <code>self</code> * and <code>other</code>, where <code>other</code> is Fixnum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Subtract(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns a new float which is the difference between <code>self</code> * and <code>other</code>, where <code>other</code> is Bignum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Subtract(System.Double,System.Double)">
            <summary>
            Returns a new float which is the difference between <code>self</code> * and <code>other</code>, where <code>other</code> is Float.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Subtract(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns a new float which is the difference between <code>self</code> * and <code>other</code>, , where <code>other</code> is not Fixnum, Bignum or Float.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Divide(System.Double,System.Int32)">
            <summary>
            Returns a new float which is the result of dividing <code>self</code> * by <code>other</code>, where <code>other</code> is Fixnum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Divide(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns a new float which is the result of dividing <code>self</code> * by <code>other</code>, where <code>other</code> is Bignum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Divide(System.Double,System.Double)">
            <summary>
            Returns a new float which is the result of dividing <code>self</code> * by <code>other</code>, where <code>other</code> is Float.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Divide(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns a new float which is the result of dividing <code>self</code> * by <code>other</code>, where <code>other</code> is not Fixnum, Bignum or Float.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Modulo(System.Double,System.Int32)">
            <summary>
            Return the modulo after division of <code>self</code> by <code>other</code>, where <code>other</code> is Fixnum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Modulo(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Return the modulo after division of <code>self</code> by <code>other</code>, where <code>other</code> is Bignum.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Modulo(System.Double,System.Double)">
            <summary>
            Return the modulo after division of <code>self</code> by <code>other</code>, where <code>other</code> is Float.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.ModuloOp(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Return the modulo after division of <code>self</code> by <code>other</code>, where <code>other</code> is not Fixnum, Bignum or Float.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Modulo(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Return the modulo after division of <code>self</code> by <code>other</code>, where <code>other</code> is not Fixnum, Bignum or Float.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Power(System.Double,System.Int32)">
            <summary>
            Raises <code>self</code> the <code>other</code> power, where other is Fixnum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Power(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Raises <code>self</code> the <code>other</code> power, where other is Bignum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Power(System.Double,System.Double)">
            <summary>
            Raises <code>self</code> the <code>other</code> power, where other is Float.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Power(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Raises <code>self</code> the <code>other</code> power, where other is not Fixnum, Bignum or Float.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.DivMod(System.Double,System.Int32)">
            <summary>
            Returns an array containing the quotient and modulus obtained by dividing <i>self</i> by <i>other</i>, where other is Fixnum.
            </summary>
            <param name="self"></param>
            <param name="other"></param>
            <returns></returns>
            <remarks>
            If <code>q, r = x.divmod(y)</code>, then
            <code>q = floor(float(x)/float(y))
            x = q*y + r</code>
            The quotient is rounded toward -infinity
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.DivMod(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns an array containing the quotient and modulus obtained by dividing <i>self</i> by <i>other</i>, where other is Bignum.
            </summary>
            <param name="self"></param>
            <param name="other"></param>
            <returns></returns>
            <remarks>
            If <code>q, r = x.divmod(y)</code>, then
            <code>q = floor(float(x)/float(y))
            x = q*y + r</code>
            The quotient is rounded toward -infinity
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.DivMod(System.Double,System.Double)">
            <summary>
            Returns an array containing the quotient and modulus obtained by dividing <i>self</i> by <i>other</i>, where other is Float
            </summary>
            <param name="self"></param>
            <param name="other"></param>
            <returns></returns>
            <remarks>
            If <code>q, r = x.divmod(y)</code>, then
            <code>q = floor(float(x)/float(y))
            x = q*y + r</code>
            The quotient is rounded toward -infinity
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.DivMod(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns an array containing the quotient and modulus obtained by dividing <i>self</i> by <i>other</i>, where other is not Fixnum, Bignum or Float.
            </summary>
            <param name="self"></param>
            <param name="other"></param>
            <returns></returns>
            <remarks>
            If <code>q, r = x.divmod(y)</code>, then
            <code>q = floor(float(x)/float(y))
            x = q*y + r</code>
            The quotient is rounded toward -infinity
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Abs(System.Double)">
            <summary>
            Returns the absolute value of <i>self</i>.
            </summary>
            <example>
             (-34.56).abs   #=> 34.56
             -34.56.abs     #=> 34.56
            </example>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Ceil(System.Double)">
            <summary>
            Returns the smallest <code>Integer</code> greater than or equal to <code>self</code>
            </summary>
            <example>
            1.2.ceil      #=> 2
            2.0.ceil      #=> 2
            (-1.2).ceil   #=> -1
            (-2.0).ceil   #=> -2
            </example>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Floor(System.Double)">
            <summary>
            Returns the largest <code>Integer</code> less than or equal to <code>self</code>.
            </summary>
            <example>
            1.2.floor      #=> 1
            2.0.floor      #=> 2
            (-1.2).floor   #=> -2
            (-2.0).floor   #=> -2
            </example>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.ToInt(System.Double)">
            <summary>
            Returns <code>self</code> truncated to an <code>Integer</code>.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Coerce(System.Double,System.Double)">
            <summary>
            Attempts to coerce other to a Float.
            </summary>
            <returns>[other, self] as Floats</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.ToFloat(System.Double)">
            <summary>
            Converts self to Float
            </summary>
            <remarks>
            As <code>self</code> is already Float, returns <code>self</code>.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Round(System.Double)">
            <summary>
            Rounds <code>self</code> to the nearest <code>Integer</code>.
            </summary>
            <remarks>
            This is equivalent to:
            <code>
            def round
                return (self+0.5).floor if self &gt; 0.0
                return (self-0.5).ceil  if self &lt; 0.0
                return 0
            end
            </code>
            </remarks>
            <example>
            1.5.round      #=> 2
            (-1.5).round   #=> -2
            </example>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.ToS(IronRuby.Runtime.RubyContext,System.Double)">
            <summary>
            Returns a string containing a representation of self.
            </summary>
            <remarks>
            As well as a fixed or exponential form of the number, the call may return
            "<code>NaN</code>", "<code>Infinity</code>", and "<code>-Infinity</code>".
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Hash(System.Double)">
            <summary>
            Returns a hash code for <code>self</code>.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Equal(System.Double,System.Double)">
            <summary>
            Returns <code>true</code> only if <i>other</i> has the same value as <i>self</i>, where other is Float
            </summary>
            <returns>True or False</returns>
            <remarks>
            Contrast this with <code>Float#eql?</code>, which requires <i>other</i> to be a <code>Float</code>.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Equal(IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns <code>true</code> only if <i>other</i> has the same value as <i>self</i>, where other is not a Float
            </summary>
            <returns>True or False</returns>
            <remarks>
            Contrast this with <code>Float#eql?</code>, which requires <i>other</i> to be a <code>Float</code>.
            Dynamically invokes other == self (i.e. swaps operands around).
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Compare(System.Double,System.Double)">
            <summary>
            Compares self with other, where other is Float.
            </summary>
            <returns>
            -1 if self is less than other
            0 if self is equal to other
            +1 if self is greater than other
            nil if self is not comparable to other (for instance if either is NaN).
            </returns>
            <remarks>
            This is the basis for the tests in <code>Comparable</code>.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Compare(System.Double,System.Int32)">
            <summary>
            Compares self with other, where other is Fixnum.
            </summary>
            <returns>
            -1 if self is less than other
            0 if self is equal to other
            +1 if self is greater than other
            nil if self is not comparable to other (for instance if either is NaN).
            </returns>
            <remarks>
            This is the basis for the tests in <code>Comparable</code>.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Compare(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Compares self with other, where other is Bignum.
            </summary>
            <returns>
            -1 if self is less than other
            0 if self is equal to other
            +1 if self is greater than other
            nil if self is not comparable to other (for instance if either is NaN).
            </returns>
            <remarks>
            This is the basis for the tests in <code>Comparable</code>.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.Compare(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Compares self with other, where other is not Float, Fixnum or Bignum.
            </summary>
            <returns>
            -1 if self is less than other
            0 if self is equal to other
            +1 if self is greater than other
            nil if self is not comparable to other (for instance if either is NaN).
            </returns>
            <remarks>
            This is the basis for the tests in <code>Comparable</code>.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.LessThan(System.Double,System.Double)">
            <summary>
            Returns true if self is less than other, where other is Float.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.LessThan(System.Double,System.Int32)">
            <summary>
            Returns true if self is less than other, where other is Fixnum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.LessThan(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns true if self is less than other, where other is Bignum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.LessThan(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns true if self is less than other, where other is not Float, Fixnum or Bignum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.LessThanOrEqual(System.Double,System.Double)">
            <summary>
            Returns true if self is less than or equal to other, where other is Float.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.LessThanOrEqual(System.Double,System.Int32)">
            <summary>
            Returns true if self is less than or equal to other, where other is Fixnum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.LessThanOrEqual(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns true if self is less than or equal to other, where other is Bignum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.LessThanOrEqual(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns true if self is less than or equal to other, where other is not Float, Fixnum or Bignum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.GreaterThan(System.Double,System.Double)">
            <summary>
            Returns true if self is greater than other, where other is Float.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.GreaterThan(System.Double,System.Int32)">
            <summary>
            Returns true if self is greater than other, where other is Fixnum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.GreaterThan(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns true if self is greater than other, where other is Bignum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.GreaterThan(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns true if self is greater than other, where other is not Float, Fixnum or Bignum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.GreaterThanOrEqual(System.Double,System.Double)">
            <summary>
            Returns true if self is greater than or equal to other, where other is Float.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.GreaterThanOrEqual(System.Double,System.Int32)">
            <summary>
            Returns true if self is greater than or equal to other, where other is Fixnum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.GreaterThanOrEqual(IronRuby.Runtime.RubyContext,System.Double,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns true if self is greater than or equal to other, where other is Bignum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.GreaterThanOrEqual(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Double,System.Object)">
            <summary>
            Returns true if self is greater than or equal to other, where other is not Float, Fixnum or Bignum.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.IsFinite(System.Double)">
            <summary>
            Returns <code>true</code> if <code>self</code> is a valid IEEE floating point number
            (it is not infinite, and <code>nan?</code> is <code>false</code>).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.IsInfinite(System.Double)">
            <summary>
            Returns <code>nil</code>, -1, or +1 depending on whether <code>self</code> is finite, -infinity, or +infinity.
            </summary>
            <example>
            (0.0).infinite?        #=> nil
            (-1.0/0.0).infinite?   #=> -1
            (+1.0/0.0).infinite?   #=> 1
            </example>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.IsNan(System.Double)">
            <summary>
            Returns <code>true</code> if <i>self</i> is an invalid IEEE floating point number.
            </summary>
            <example>
            a = -1.0      #=> -1.0
            a.nan?        #=> false
            a = 0.0/0.0   #=> NaN
            a.nan?        #=> true
            </example>
        </member>
        <member name="M:IronRuby.Builtins.ClrFloat.IsZero(System.Double)">
            <summary>
            Returns <code>true</code> if <code>self</code> is 0.0.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.ClrInteger">
            <summary>
            Mixed-in all .NET numeric primitive types that can be widened to 32 bit signed integer 
            (byte, sbyte, short, ushort, int). 
            
            TODO: we might want to specialize some of the methods to preserve the exact type if possible (like adding byte and byte).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.LeftShift(System.Int32,System.Int32)">
            <summary>
            Returns the value after shifting to the left (right if count is negative) the value in self by other bits.
            (where other is Fixnum)
            </summary>
            <returns>The value after the shift</returns>
            <remarks>Converts to Bignum if the result cannot fit into Fixnum</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.LeftShift(IronRuby.Runtime.RubyContext,System.Int32,IronRuby.Runtime.IntegerValue)">
            <summary>
            Returns the value after shifting to the left (right if count is negative) the value in self by other bits.
            (where other is not Fixnum)
            </summary>
            <returns>The value after the shift</returns>
            <remarks>Converts to Bignum if the result cannot fit into Fixnum</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.RightShift(System.Int32,System.Int32)">
            <summary>
            Returns the value after shifting to the right (left if count is negative) the value in self by other bits.
            (where other is Fixnum)
            </summary>
            <returns>The value after the shift</returns>
            <remarks>Converts to Bignum if the result cannot fit into Fixnum</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.RightShift(IronRuby.Runtime.RubyContext,System.Int32,IronRuby.Runtime.IntegerValue)">
            <summary>
            Returns the value after shifting to the right (left if count is negative) the value in self by other bits.
            (where other is not Fixnum)
            </summary>
            <returns>The value after the shift</returns>
            <remarks>Converts to Bignum if the result cannot fit into Fixnum</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Bit(System.Int32,System.Int32)">
            <summary>
            Returns the value of the bit at the indexth bit position of self, where index is Fixnum
            </summary>
            <example>
            <code>
              a = 9**15
              50.downto(0) do |n|
                print a[n]
              end
            </code>
            produces: 
            <code>
              000101110110100000111000011110010100111100010111001
            </code>
            </example>
            <returns>indexth bit in the (assumed) binary representation of self, where self[0] is the least significant bit.</returns>
            <remarks>Since representation is supposed to be 2s complement, we return always 1 if self is negative and index is greater than most signifcant bit in BigInteger</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Bit(System.Int32,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns the value of the bit at the indexth bit position of self, where index is Bignum
            </summary>
            <returns>
            0 if index is negative or self is positive
            1 otherwise
            </returns>
            <remarks>
            Since representation is supposed to be 2s complement and index must be extremely big,
            we asssume we can always return 1 if self is negative and 0 otherwise</remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.BitwiseXor(System.Int32,System.Int32)">
            <summary>
            Performs bitwise XOR on self and other
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.BitwiseXor(System.Int32,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Performs bitwise XOR on self and other
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.BitwiseXor(IronRuby.Runtime.RubyContext,System.Int32,IronRuby.Runtime.IntegerValue)">
            <summary>
            Performs bitwise XOR on self and other, where other is not Fixnum or Bignum
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.BitwiseAnd(System.Int32,System.Int32)">
            <summary>
            Performs bitwise AND on self and other, where other is Fixnum
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.BitwiseAnd(System.Int32,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Performs bitwise AND on self and other, where other is Bignum
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.BitwiseAnd(IronRuby.Runtime.RubyContext,System.Int32,IronRuby.Runtime.IntegerValue)">
            <summary>
            Performs bitwise AND on self and other, where other is not Fixnum or Bignum
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.BitwiseOr(System.Int32,System.Int32)">
            <summary>
            Performs bitwise OR on self and other
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.BitwiseOr(System.Int32,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Performs bitwise OR on self and other
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.BitwiseOr(IronRuby.Runtime.RubyContext,System.Int32,IronRuby.Runtime.IntegerValue)">
            <summary>
            Performs bitwise OR on self and other, where other is not Fixnum or Bignum
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.OnesComplement(System.Int32)">
            <summary>
            Returns the ones complement of self; a number where each bit is flipped. 
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Multiply(System.Int32,System.Int32)">
            <summary>
            Returns self multiplied by other, where other is Fixnum or Bignum.
            </summary>
            <returns>
            Returns either Fixnum or Bignum if the result is too large for Fixnum.
            </returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Multiply(System.Int32,Microsoft.Scripting.Math.BigInteger)">
            <summary>
            Returns self multiplied by other, where other is Fixnum or Bignum.
            </summary>
            <returns>
            Returns either Fixnum or Bignum if the result is too large for Fixnum.
            </returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Multiply(System.Int32,System.Double)">
            <summary>
            Returns self multiplied by other, where other is Float.
            </summary>
            <returns>
            Returns a Float
            </returns>
            <remarks>
            Converts self to a float and multiplies the two floats directly.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Multiply(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns self multiplied by other.
            </summary>
            <returns>
            The class of the resulting object depends on the class of other and on the magnitude of the result. 
            </returns>
            <remarks>
            Self is first coerced by other and then the * operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Power(System.Int32,System.Int32)">
            <summary>
            Raises self to the other power, which may be negative.
            </summary>
            <returns>
            Integer (Bignum or Fixnum) if other is positive
            Float otherwise.
            </returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Power(System.Int32,System.Double)">
            <summary>
            Raises self to the other power, which may be negative or fractional.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Power(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.RubyContext,System.Int32,System.Object)">
            <summary>
            Raises self to the other power, where other is not Integer or Float.
            </summary>
            <remarks>
            Self is first coerced by other and then the ** operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Add(System.Int32,System.Int32)">
            <summary>
            Returns self added to other, where other is Fixnum.
            </summary>
            <returns>Fixnum or Bignum if result is too large for Fixnum.</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Add(System.Int32,System.Double)">
            <summary>
            Returns self added to other, where other is Float
            </summary>
            <returns>Float</returns>
            <remarks>
            Converts self to Float and then adds the two floats directly.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Add(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns self added to other.
            </summary>
            <returns>
            The class of the resulting object depends on the class of other and on the magnitude of the result. 
            </returns>
            <remarks>
            Self is first coerced by other and then the + operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Subtract(System.Int32,System.Int32)">
            <summary>
            Subtracts other from self (i.e. self - other), where other is Fixnum.
            </summary>
            <returns>Fixnum, or Bignum if result is too large for Fixnum.</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Subtract(System.Int32,System.Double)">
            <summary>
            Subtracts other from self (i.e. self - other), where other is Float.
            </summary>
            <returns>Float</returns>
            <remarks>
            Converts self to a double then executes the subtraction directly.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Subtract(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.RubyContext,System.Object,System.Object)">
            <summary>
            Subtracts other from self (i.e. self - other), where other is not Fixnum, or Float.
            </summary>
            <returns>
            The class of the resulting object depends on the class of other and on the magnitude of the result. 
            </returns>
            <remarks>
            Self is first coerced by other and then the - operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Divide(System.Int32,System.Int32)">
            <summary>
            Divides self by other, where other is a Fixnum.
            Aliased as / and div
            </summary>
            <returns>Fixnum, or Bignum if result is too large for Fixnum.</returns>
            <remarks>
            Since both operands are Integer, the result returned is Integer, rounded toward -Infinity.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.DivideOp(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Divides self by other, where other is not a Fixnum.
            </summary>
            <returns>
            The class of the resulting object depends on the class of other and on the magnitude of the result. 
            </returns>
            <remarks>
            Self is first coerced by other and then the / operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Divide(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Divides self by other, where other is not a Fixnum.
            </summary>
            <returns>
            The class of the resulting object depends on the class of other and on the magnitude of the result. 
            </returns>
            <remarks>
            Self is first coerced by other and then the div method is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Modulo(System.Int32,System.Int32)">
            <summary>
            Returns self modulo other, where other is Fixnum.  See <see cref="!:FloatOps.Divmod"/> for more information.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.ModuloOp(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns self % other, where other is not Fixnum.
            </summary>
            <remarks>
            First coerces self on other then calls % on the coerced self value.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Modulo(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns self modulo other, where other is not Fixnum.
            </summary>
            <remarks>
            First coerces self on other then calls modulo on the coerced self value.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.DivMod(System.Int32,System.Int32)">
             <summary>
             Returns an array containing the quotient and modulus obtained by dividing self by other.
             </summary>
             <returns>RubyArray of the form: [div, mod], where div is Integer</returns>
             <remarks>
             If q, r = x.divmod(y), then 
                q = floor(float(x)/float(y))
                x = q*y + r
             The quotient is rounded toward -infinity, as shown in the following table: 
            
               a    |  b  |  a.divmod(b)  |   a/b   | a.modulo(b) | a.remainder(b)
              ------+-----+---------------+---------+-------------+---------------
               13   |  4  |   3,    1     |   3     |    1        |     1
              ------+-----+---------------+---------+-------------+---------------
               13   | -4  |  -4,   -3     |  -4     |   -3        |     1
              ------+-----+---------------+---------+-------------+---------------
              -13   |  4  |  -4,    3     |  -4     |    3        |    -1
              ------+-----+---------------+---------+-------------+---------------
              -13   | -4  |   3,   -1     |   3     |   -1        |    -1
              ------+-----+---------------+---------+-------------+---------------
               11.5 |  4  |   2,    3.5   |   2.875 |    3.5      |     3.5
              ------+-----+---------------+---------+-------------+---------------
               11.5 | -4  |  -3,   -0.5   |  -2.875 |   -0.5      |     3.5
              ------+-----+---------------+---------+-------------+---------------
              -11.5 |  4  |  -3,    0.5   |  -2.875 |    0.5      |    -3.5
              ------+-----+---------------+---------+-------------+---------------
              -11.5 | -4  |   2    -3.5   |   2.875 |   -3.5      |    -3.5
             </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.DivMod(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Int32,System.Object)">
            <summary>
            Returns an array containing the quotient and modulus obtained by dividing self by other.
            </summary>
            <returns>RubyArray of the form: [div, mod], where div is Integer</returns>
            <remarks>
            Self is first coerced by other and then the divmod method is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Abs(System.Int32)">
            <summary>
            Returns the absolute value of self.
            </summary>
            <returns>Fixnum</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Quotient(System.Int32,System.Int32)">
            <summary>
            Returns the floating point result of dividing self by other, where other is Fixnum. 
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Quotient(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Int32,System.Object)">
            <summary>
            Returns the floating point result of dividing self by other, where other is not Fixnum. 
            </summary>
            <remarks>
            Self is first coerced by other and then the quo method is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.IsZero(System.Int32)">
            <summary>
            Returns true if self is zero.
            </summary>
            <returns>True if self is zero, false otherwise.</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.LessThan(System.Int32,System.Int32)">
            <summary>
            Returns true if the value of self is less than other, where other is Fixnum.
            </summary>
            <returns>True or false</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.LessThan(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns true if the value of self is less than other, where other is not Fixnum.
            </summary>
            <returns>True or false</returns>
            <remarks>
            Self is first coerced by other and then the &lt; operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.LessThanOrEqual(System.Int32,System.Int32)">
            <summary>
            Returns true if the value of self is less than or equal to other, where other is Fixnum.
            </summary>
            <returns>True or false</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.LessThanOrEqual(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns true if the value of self is less than or equal to other, where other is not Fixnum.
            </summary>
            <returns>True or false</returns>
            <remarks>
            Self is first coerced by other and then the &lt;= operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Compare(System.Int32,System.Int32)">
            <summary>
            Comparison: Returns -1, 0, or +1 depending on whether self is less than, equal to, or greater than other, where other is Fixnum.
            </summary>
            <returns>
            -1 if self is less than other
            0 if self is equal to other
            +1 if self is greater than other
            nil if self cannot be compared to other
            </returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Compare(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Comparison: Returns -1, 0, or +1 depending on whether self is less than, equal to, or greater than other, where other is not Fixnum.
            </summary>
            <returns>
            -1 if self is less than other
            0 if self is equal to other
            +1 if self is greater than other
            nil if self cannot be compared to other
            </returns>
            <remarks>
            Self is first coerced by other and then the &lt;=&gt; operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Equal(System.Int32,System.Int32)">
            <summary>
            Test whether self is numerically equivalent to other.  (Does not require type equivalence).
            </summary>
            <returns>True if self and other are numerically equal.</returns>
            <remarks>
            Since other is Fixnum here, we just test for direct equality.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.Equal(IronRuby.Runtime.BinaryOpStorage,System.Int32,System.Object)">
            <summary>
            Test whether self is numerically equivalent to other.  (Does not require type equivalence).
            </summary>
            <returns>True if self and other are numerically equal.</returns>
            <remarks>
            Since other is not Fixnum, we turn the equivalence check around,
            i.e. call other == self
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.GreaterThan(System.Int32,System.Int32)">
            <summary>
            Returns true if the value of self is greater than other, where other is Fixnum.
            </summary>
            <returns>True or false</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.GreaterThan(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns true if the value of self is greater than other, where other is not Fixnum.
            </summary>
            <returns>True or false</returns>
            <remarks>
            Self is first coerced by other and then the &gt; operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.GreaterThanOrEqual(System.Int32,System.Int32)">
            <summary>
            Returns true if the value of self is greater than or equal to other, where other is Fixnum.
            </summary>
            <returns>True or false</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.GreaterThanOrEqual(IronRuby.Runtime.BinaryOpStorage,IronRuby.Runtime.BinaryOpStorage,System.Object,System.Object)">
            <summary>
            Returns true if the value of self is greater than or equal to other, where other is not Fixnum.
            </summary>
            <returns>True or false</returns>
            <remarks>
            Self is first coerced by other and then the &gt;= operator is invoked on the coerced self.
            </remarks>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.ToFloat(System.Int32)">
            <summary>
            Convert self to Float.
            </summary>
            <returns>Float version of self</returns>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.ToString(System.Object)">
            <summary>
            Returns a string representing the value of self using base 10.
            </summary>
            <returns>MutableString</returns>
            <example>12345.to_s => "12345"</example>
        </member>
        <member name="M:IronRuby.Builtins.ClrInteger.ToString(Microsoft.Scripting.Math.BigInteger,System.Int32)">
            <summary>
            Returns a string representing the value of self using base radix.
            </summary>
            <returns>MutableString</returns>
            <example>
            12345.to_s(2)    #=> "11000000111001"
            12345.to_s(8)    #=> "30071"
            12345.to_s(10)   #=> "12345"
            12345.to_s(16)   #=> "3039"
            12345.to_s(36)   #=> "9ix"
            </example>
        </member>
        <member name="M:IronRuby.Builtins.ClrNameOps.Unmangle(IronRuby.Builtins.RubyClass,System.String)">
            <summary>
            Converts a Ruby name to PascalCase name (e.g. "foo_bar" to "FooBar").
            Returns null if the name is not a well-formed Ruby name (it contains upper-case latter or subsequent underscores).
            Characters that are not upper case letters are treated as lower-case letters.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.ClrNameOps.Mangle(IronRuby.Builtins.RubyClass,System.String)">
            <summary>
            Converts a camelCase or PascalCase name to a Ruby name (e.g. "FooBar" to "foo_bar").
            Returns null if the name is not in camelCase or PascalCase (FooBAR, foo, etc.).
            Characters that are not upper case letters are treated as lower-case letters.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.ClrString">
            <summary>
            Mixed into System::String and System::Char.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.DecimalOps.InducedFrom(IronRuby.Builtins.RubyModule,System.Double)">
            <summary>
            Convert value to Float, where value is Float.
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:IronRuby.Builtins.DecimalOps.ToInt(System.Decimal)">
            <summary>
            Returns <code>self</code> truncated to an <code>Integer</code>.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.FlagEnumerationOps">
            <summary>
            Implements operations on flag enumeration.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.IListOps.EnumerateRecursively(IronRuby.Runtime.ConversionStorage{System.Collections.IList},System.Collections.IList,System.Int32,System.Func{System.Collections.IList,System.Object})">
            <summary>
            Enumerates all items of the list recursively - if there are any items convertible to IList the items of that lists are enumerated as well.
            Returns null if there are no nested lists and so the list can be enumerated using a standard enumerator.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.IronRubyOps.GetLoadedScripts(IronRuby.Runtime.RubyContext,IronRuby.Builtins.RubyModule)">
            <summary>
            Gets a live read-only and thread-safe dictionary that maps full paths of the loaded scripts to their scopes.
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.IronRubyOps.Require(IronRuby.Runtime.RubyScope,IronRuby.Builtins.RubyModule,IronRuby.Builtins.MutableString)">
            <summary>
            The same as Kernel#require except for that it returns the loaded Assembly or Scope (even if already loaded).
            </summary>
        </member>
        <member name="M:IronRuby.Builtins.IronRubyOps.Load(IronRuby.Runtime.RubyScope,IronRuby.Builtins.RubyModule,IronRuby.Builtins.MutableString)">
            <summary>
            The same as Kernel#require except for that it returns the loaded Assembly or Scope.
            </summary>
        </member>
        <member name="T:IronRuby.Builtins.MultiDimensionalArrayOps">
            <summary>
            Implements operations on multi-dimensional CLR array.
            TODO: implement all IList methods that don't work on multi-dim arrays.
            </summary>
        </member>
    </members>
</doc>
